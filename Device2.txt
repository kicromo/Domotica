#include <linux/module.h> #include <linux/kernel.h> #include <linux/init.h>
#include <linux/miscdevice.h> // misc dev #include <linux/fs.h>	// file operations
#include <linux/uaccess.h>		// copy to/from user space #include <linux/wait.h>	// waiting queue
#include <linux/sched.h>	// TASK_INTERRUMPIBLE #include <linux/delay.h>	// udelay

#include <linux/interrupt.h> #include <linux/gpio.h> #include <linux/slab.h> #include <linux/printk.h> #include <linux/list.h> #include <linux/timer.h>

#define DRIVER_AUTHOR "Aram Oganesyan" #define DRIVER_DESC	"Segundo Driver"
//GPIOS numbers as in BCM RPi #define GPIO_BUTTON1 2
#define GPIO_BUTTON2 3

#define GPIO_SPEAKER 4

#define GPIO_GREEN1 27
#define GPIO_GREEN2 22
#define GPIO_YELLOW1 17
#define GPIO_YELLOW2 11
#define GPIO_RED1	10
#define GPIO_RED2	9
 
#define GPIO_BUTTON1_DESC #define GPIO_BUTTON2_DESC 
 
"Boton 1"
"Boton 2"
 
#define GPIO_BUTTON_DEVICE_DESC "Placa lab. Dac"

#define LOW_LEVEL '0'
#define HIGH_LEVEL '1'

/// frecuencias:

const int c = 261; const int d = 294; const int e = 329; const int f = 349; const int g = 391; const int gS = 415; const int a = 440; const int aS = 455; const int b = 466; const int cH = 523;
 
const int cSH = 554; const int dH = 587; const int dSH = 622; const int eH = 659; const int fH = 698; const int fSH = 740; const int gH = 784; const int gSH = 830; const int aH = 880;

static int LED_GPIOS[]= {GPIO_GREEN1, GPIO_GREEN2, GPIO_YELLOW1, GPIO_YELLOW2, GPIO_RED1, GPIO_RED2} ;

static char *led_desc[]=
{"GPIO_GREEN1","GPIO_GREEN2","GPIO_YELLOW1","GPIO_YELLOW2","GPIO_RED1","GPIO_RED 2"} ;


static short int irq_BUTTON1 = 0; static short int irq_BUTTON2 = 1;

static void tasklet_handler(unsigned long);

DECLARE_TASKLET(tasklet_boton1, tasklet_handler,1); DECLARE_TASKLET(tasklet_boton2,tasklet_handler,2);

static unsigned long ticks_unsegundo; static void timer_handler(unsigned long);

DEFINE_TIMER(timer_uno,timer_handler,0,0); DECLARE_WAIT_QUEUE_HEAD(espera);
DEFINE_SEMAPHORE(semaforo); DEFINE_SEMAPHORE(open_release_semaphore); DEFINE_SEMAPHORE(open_release_semaphore_speaker);

int bloqueo = 1;
/*****************************************************/
/*	LISTA CIRCUILAR	*/
/*****************************************************/

typedef struct _nodo {
 	int id;
 	int dato;
 	struct _nodo *siguiente;
}tipoNodo;

typedef tipoNodo *pNodo; typedef tipoNodo *Lista;

Lista lista;

static void insertar(Lista *lista,int v){
 
 	struct _nodo* nodo;

 	nodo = (struct _nodo *)kmalloc(sizeof(struct _nodo),GFP_KERNEL);
 	nodo->dato = v;
 	if((*lista) == NULL){
 	 	nodo->id = 1;
 	 	*lista = nodo;
 	}
 	else{
 	 	nodo->id = ((*lista)->siguiente)->id+1;
 	 	nodo->siguiente = (*lista)->siguiente;
 	}

 	(*lista)->siguiente=nodo;

}
static int empty(Lista *lista){
 	return (*lista == NULL) ? 0: 1;
}
static void mostrar(Lista *lista){
 	pNodo Nodo = *lista;
 	if(*lista==NULL){printk(KERN_INFO"LISTA VACIA");
 	}else{
 	while(Nodo->siguiente!=*lista){
 	 	printk(KERN_INFO"Nodo %d ->%d",Nodo->id,Nodo->dato);
 	 	Nodo = Nodo->siguiente;
 	}
 	}

}
static void borrar(Lista*lista){
 	pNodo nodo;
 	if((*lista)->id == (((*lista)->siguiente)->id)){
 	 	kfree(*lista);
 	 	*lista = NULL;
 	}else{
 	 	nodo=(*lista)->siguiente;
 	 	(*lista)->siguiente = nodo->siguiente;
 	 	kfree(nodo);
 	}
}
static int pulsaciones(Lista *lista){
 	return (*lista != NULL)?(((*lista)->siguiente)->dato) : 0;
}
/*****************************************************/
/*	FUNCIONES LEDS	*/
/*****************************************************/

static char leds2byte(void){
 	int val;
 	char ch;
 	int i;
 	ch = 0;
 	for(i = 0; i<6; i++){
 
 	 	val=gpio_get_value(LED_GPIOS[i]);
 	 	ch = ch | (val <<i);
 	}	
 
}	return	ch;

static void byte2leds(char ch)
{

int i;
int val=(int)ch;
 	int currentval =(int)leds2byte();
 		int formato = (11000000 & val) >> 6; switch(formato){
 	 	 	case 0:
 	 	 	 	for(i=0; i<6; i++) gpio_set_value(LED_GPIOS[i], (val >> i) & 1);
 	 	 	break;
 	 	 	case 1:

 	 	 	 	for(i=0; i<6; i++) gpio_set_value(LED_GPIOS[i],((currentval >> i)&1)|((val >> i)&1));
 	 	 	break;
 	 	 	case 2:
 	 	 	 	val=~val;
 	 	 	 	for(i=0; i<6; i++) gpio_set_value(LED_GPIOS[i],((currentval >>i)&1)&((val >> i)&1));
 	 	 	break;
 	 	 	case 3:
 	 	 	break;
 	}
 	printk(KERN_INFO"valor de k: %d\n",formato);

}


/*********************************************************************/
/*	TIMER HANDLER	*/
/********************************************************************/

static void timer_handler(unsigned long dato){
 	enable_irq(irq_BUTTON1);
 	enable_irq(irq_BUTTON2);
}

/*********************************************************************/
/*	TASKLET HANDLER	*/
/********************************************************************/

static void tasklet_handler(unsigned long dato){
 	printk(KERN_INFO"(TASKLET) - 1");
 	//down(&semaforo);
 	printk(KERN_INFO"(TASKLET) - 2");
 	insertar(&lista,(int)dato);
 
//up(&semaforo);
 	printk(KERN_INFO "INSERTADO");
 	mostrar(&lista);
 	wake_up(&espera);
 	printk(KERN_INFO"(TASKLET) - 3");
}
/*********************************************************************/
/*	IRQ HANDLER	*/
/********************************************************************/
static irqreturn_t r_irq_handler1(int irq, void *dev_id, struct pt_regs *regs){
 	disable_irq_nosync(irq_BUTTON1);
 	disable_irq_nosync(irq_BUTTON2);

 	mod_timer(&timer_uno,jiffies+ticks_unsegundo/6);
 	if(irq==irq_BUTTON1) tasklet_schedule(&tasklet_boton1);
 	else tasklet_schedule(&tasklet_boton2);

 	return IRQ_HANDLED;
}

static int b_open(struct inode *inode, struct file *filp){
 	printk(KERN_INFO"Fichero abierto\n");
 	if(down_trylock(&open_release_semaphore)){
 	 	return -EBUSY;
 	}

 	return 0;
}
static int b_release(struct inode *inode, struct file *filp){
 	printk(KERN_INFO"Releasing semaphore\n");
 	up(&open_release_semaphore);

 	return 0;
}
static ssize_t b_read(struct file *file, char user *buf,
 	 	 	 	 	 	size_t count, loff_t *ppos){
 	int len;
char suppbuff[1024]; int pulsac;

 	//if(*ppos > 0) return 0;

 	if(down_interruptible(&semaforo)) return -ERESTARTSYS;

 	while(!(empty(&lista))){
 	 	up(&semaforo);
 	 	printk(KERN_INFO" (read) bloqueado 1");
 	 	if(wait_event_interruptible(espera,empty(&lista))) return
-ERESTARTSYS;

 	 	if(down_interruptible(&semaforo)) return -ERESTARTSYS;
 	}
 	printk(KERN_INFO" (read) desbloqeuado 1");
 	pulsac = pulsaciones(&lista);
 
 	len = sprintf(suppbuff,"%d",pulsac);
 	if(copy_to_user(buf,suppbuff,(len>count)?count:len)){
 	 	return -EFAULT;
 	}
 	borrar(&lista);

 	*ppos+=len;

 	up(&semaforo);
 	return len;

}
static ssize_t a_read(struct file *file, char user *buf,
 	 	 	 	 	 	size_t count, loff_t *ppos){
 	char ch;

 	if(*ppos==0)*ppos+=1;
 	else return 0;

 	ch = leds2byte();
 	printk(KERN_INFO" (read) valor entregado %d\n",(int)ch);
 	if(copy_to_user(buf,&ch,1)) return -EFAULT;

 	return 1;
}

static ssize_t a_write(struct file *file, const char user *buf,
size_t count, loff_t *ppos)
{

char ch;

if (copy_from_user( &ch, buf, 1 )) { return -EFAULT;
}

printk( KERN_INFO " (write) valor recibido: %d\n",(int)ch); byte2leds(ch);
return 1;
}

static const struct file_operations b_fops = {
 
.owner 
.read 
.open 
 
= THIS_MODULE,
= b_read,
= b_open,
 
 	.release = b_release,
};
static const struct file_operations a_fops = {
 
 	.owner 
 	.read 
 	.write 
};
 
= THIS_MODULE,
= a_read,
= a_write,
 
/****************************************************************************/
/* device struct	*/
/****************************************************************************/ static struct miscdevice b_miscdev = {
 
.minor 
.name 
 
= MISC_DYNAMIC_MINOR,
= "bloqueo",
 
.fops	= &b_fops,
.mode	= S_IRUGO | S_IWUGO,
};

static struct miscdevice a_miscdev = {
 
.minor 
.name 
.fops 
 
= MISC_DYNAMIC_MINOR,
= "leds",
= &a_fops,
 

};


static int r_dev_config_block(void){
 	int ret=0;
 	ret = misc_register(&b_miscdev);
 	if(ret < 0){
 	printk(KERN_ERR "misc_register failed\n");

 	}else{
 	 	printk(KERN_NOTICE"misc_register OK... b_miscdev.minor=%d\n",ret);
 	}

 	return ret;
}
static int r_dev_config_leds(void){
 	int ret=0;
 	ret = misc_register(&a_miscdev);
 	if(ret < 0){
 	printk(KERN_ERR "misc_register failed\n");

 	}else{
 	 	printk(KERN_NOTICE"misc_register OK... a_miscdev.minor=%d\n",ret);
 	}
 	return ret;

}
static int r_int_config(void)
{
 	int res=0;
if ((res=gpio_request(GPIO_BUTTON1, GPIO_BUTTON1_DESC))) { printk(KERN_ERR "GPIO request faiure: %s\n", GPIO_BUTTON1_DESC); return res;
}

if ((res=gpio_set_debounce(GPIO_BUTTON1, 200))) {
 
printk(KERN_ERR "GPIO set_debounce failure: %s, error: %d\n", GPIO_BUTTON1_DESC, res);
printk(KERN_ERR "errno: 524 => ENOTSUPP, Operation is not supported\n");
}

if ( (irq_BUTTON1 = gpio_to_irq(GPIO_BUTTON1)) < 0 ) {
printk(KERN_ERR "GPIO to IRQ mapping faiure %s\n", GPIO_BUTTON1_DESC); return irq_BUTTON1;
}

printk(KERN_NOTICE " Mapped int %d for button1 in gpio %d\n", irq_BUTTON1, GPIO_BUTTON1);

 	if ((res=gpio_request(GPIO_BUTTON2, GPIO_BUTTON2_DESC))) { printk(KERN_ERR "GPIO request faiure: %s\n", GPIO_BUTTON2_DESC); return res;
}

if ((res=gpio_set_debounce(GPIO_BUTTON2, 200))) {
printk(KERN_ERR "GPIO set_debounce failure: %s, error: %d\n", GPIO_BUTTON2_DESC, res);
printk(KERN_ERR "errno: 524 => ENOTSUPP, Operation is not supported\n");
}

if ( (irq_BUTTON2 = gpio_to_irq(GPIO_BUTTON2)) < 0 ) {
printk(KERN_ERR "GPIO to IRQ mapping faiure %s\n", GPIO_BUTTON2_DESC); return irq_BUTTON2;
}

printk(KERN_NOTICE " Mapped int %d for button1 in gpio %d\n", irq_BUTTON2, GPIO_BUTTON2);


if ((res=request_irq(irq_BUTTON1,
(irq_handler_t ) r_irq_handler1, IRQF_TRIGGER_FALLING, GPIO_BUTTON1_DESC, GPIO_BUTTON_DEVICE_DESC))) {
printk(KERN_ERR "Irq Request failure\n"); return res;
}

if ((res=request_irq(irq_BUTTON2,
(irq_handler_t ) r_irq_handler1, IRQF_TRIGGER_FALLING, GPIO_BUTTON2_DESC, GPIO_BUTTON_DEVICE_DESC))) {
printk(KERN_ERR "Irq Request failure\n"); return res;
}



return res;
 
}


static int r_GPIO_config(void)
{
int i; int res=0;
for(i=0; i<6; i++)
{
if ((res=gpio_request_one(LED_GPIOS[i], GPIOF_INIT_LOW, led_desc[i])))
{
printk(KERN_ERR "GPIO request faiure: led GPIO %d
%s\n",LED_GPIOS[i], led_desc[i]);
return res;
}
gpio_direction_output(LED_GPIOS[i],0);
 	}

 	return res;
}


/****************************************************************************/
/* Module init / cleanup block.	*/
/****************************************************************************/

static void r_cleanup(void) { int i;

 		printk(KERN_NOTICE "%s module cleaning up...\n", KBUILD_MODNAME); if (b_miscdev.this_device) misc_deregister(&b_miscdev);
 	if (a_miscdev.this_device) misc_deregister(&a_miscdev);

 



irq irq
 
for(i=0; i<6; i++) gpio_free(LED_GPIOS[i]);
if(irq_BUTTON1) free_irq(irq_BUTTON1, GPIO_BUTTON_DEVICE_DESC);	//libera

gpio_free(GPIO_BUTTON1); // libera GPIO
if(irq_BUTTON2) free_irq(irq_BUTTON2, GPIO_BUTTON_DEVICE_DESC);	//libera gpio_free(GPIO_BUTTON2); // libera GPIO
 
 	tasklet_kill(&tasklet_boton1);
 	tasklet_kill(&tasklet_boton2);

 	del_timer(&timer_uno);
 	//while(*lista!=NULL) borrar(&lista);
 		printk(KERN_NOTICE "Done. Bye from %s module\n", KBUILD_MODNAME); return;
}

static int r_init(void){
 	int res = 0;
 	ticks_unsegundo = msecs_to_jiffies(1000);
 
 		printk(KERN_NOTICE "Hello, loading %s module\n",KBUILD_MODNAME); printk(KERN_NOTICE "%s - devices config...\n", KBUILD_MODNAME);

if((res = r_dev_config_block()))
{
 
 	 
 	r_cleanup();
return res;
 	}	
 	if((res	= r_dev_config_leds()))
 	{	
 	 	r_cleanup();
 	 	return res;
 	}	


 	printk(KERN_NOTICE "%s - INT config...\n", KBUILD_MODNAME);

 	if((res = r_int_config()))
{
 	 	r_cleanup();
 	 	return res;
 	}
if((res = r_GPIO_config())){
 	 	r_cleanup();
 	 	return res;
 	}
 		lista = NULL; return res;
}
module_init(r_init); module_exit(r_cleanup);

/****************************************************************************/
/* Module licensing/description block.	*/
/****************************************************************************/ MODULE_LICENSE("GPL");
MODULE_AUTHOR(DRIVER_AUTHOR); MODULE_DESCRIPTION(DRIVER_DESC);
